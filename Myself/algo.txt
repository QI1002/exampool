
[Elements Chapter 1-7]
- linked list
- stack
- queue
- tree
  > terminal node (leaf node) as external node
  > non-terminal node as internal node
  > full binary tree or balanced binary tree (the depth of leaf nodes are x or x+1)
  > complete binary tree (the depth of leaf nodes are x)
  > traversal order: preorder:(p,l,r), inorder:(l,p,r), postorder:(l,r,p) (inorder name from math expr, ex: 2+3)
                    and level-order traversal 
    - easy to implement preorder by stack and level-order by queue  
  > recursive => remove it 
                 1. one call one : change to use loop replace it
                 2. one call X (X>1): easy to change to use one call X-1 with loop
                 3. use one stack (ex: tree preorder traversal)
                 4. use two stack (ex: tree postorder traversal)
- complexity 
  > C(N) = C(N-1)+N => C(N) = N^2/2
  > C(N) = C(N/2)+1 => C(N) = N
  > C(N) = C(N/2)+N => C(N) = 2N
  > C(N) = 2*C(N/2)+N => C(N) = NlogN
  > C(N) = 2*C(N/2)+1 => C(N) = 2N 


TODO: 
[1]. check the tree traverse implementation of inorder and postorder

[Sort algorithms Chapter 8-13]

		   BestO AvgO  WorseO Memory Stable Compare Swap    Note  	                 
Selection Sort     N^2	 N^2   N^2    1      No     N^2/2   N       better for large data but small key 
Insertion Sort     N	 N^2   N^2    1      Yes    N^2/4   N^2/8   linear for a sorted data and assignment = 1/2 swap => N^2/8
Bubble Sort        N     N^2   N^2    1      Yes    N^2/2   N^2/2   linear for a sorted data but more swaps

Quick Sort         NlogN NlogN N^2    logN   No     2NlogN  N/3logN 
Heap Sort                NlogN NlogN  1      No     2NlogN          no extra space is needed so O(1)
Merge Sort         NlogN NlogN NlogN  N      Yes    NlogN           insensible to initial data

Shell Sort         NlogN -     -      -      No     N^(3/2)         use insertion sort hierarchically (steps = /3)
MSB Radix Sort     -     n*k/d n*k/d  n+2^d  Yes                    recursive (k = key bits, d = division bits) 
LSB Radix Sort     -     n*k/d n*k/d  n+2^d  Yes                    no recursive and reply on stable character
External Sort                                                       multiple way merge sort

TODO: 
1. why selection is not stable, why stable need O(n) extra space ?
   the swap make instable and we can use insert to replace swap and then stable
{2}. review the quicksort and heapsort algorithm 


[Graph Chapter 29]

1. The terms about graph 
   - vertices, edges, connected
   - path, simple path (no vertices repeat) and cycle 
   - a graph without cycles -> tree, forest (connected components) and spinning tree (subtree as tree)
   - a tree with V vertices has exactly V-1 edges
   - complete, dense and sparse graphs
   - directed/undirected graph, weighted graph
   - space complexity : matrix O(V^2) but adjacency list O(V+E) 
   - depth first search (visit far to start as more as possible) - by stack
   - breadth first search (visit closed to start as more as possible) - by queue  
   - biconnected : all paris of veritices has the two path to connect each other in a graph
   - articulation point (find by DFS way)
   
2. union problem 
   - use one array => add ~= O(N^2) but find ~= O(1)  
   - use one array + more set => add ~= O(N) but find ~= O(1)
   - use one array but link list => add ~= O(1) but find ~= O(N^2)

3. Famous weighted graph problems 
   - min spinning tree 
     1. priority tree search : search from one vertice and use smallest edge to visit the next node   O((E+V)logV)
     2. kruskal's method : put from smallest edge first to largest, if there is cycle, skip the edge  O(ElogE)
   - min shortest path 
     1. if every weight is the same, use BFS to find 
     2. if every weight is not the same, use priority tree search O((E+V)logV)
   - Geometic min spanning tree 
     1. use Voronoi diagram -> take dual egde of it and tree will be it's subgraph O(NlogN)

3. directed graph
   - up edge : to ascendant, down edge: to descendant, cross edge : not ascendant or descendant 
   - tranasitive closure : if x can goto y, y can goto j, then x can goto j 
     1. use DFS/BFS to find all nodes from start 
     2. use Warshall's algorithm (spare graph: O(V(E+V)), dense O(V^3)
   - use Flord's algorithm to short directed path in weighted directed graph 
   - direct acyclic graph 
   - topological sorting ( task dependancy ) 
     1. find the source node ( only output, no input ) 
     2. use them to do DFS
     3. if there is no up edge, you can find it's ropological order  
   - strong connected components
     0. a set of vertices in the directed graph and any pairs in the set can access each other 
     1. by O(N) but ingenerous flow based on DFS
     2. to find the cycle in the directed graph 
4. Network flow: skip 
5. Matching 
 
TODO:
[1]. check why kruskal's method is O(ElogE)
[2]. what's prim algorithm ?
[3]. what's Dijkstra's algorithm ?
[4]. what's major spirit in Warshall's algorithm ? 
[5]. how to find string connected commponents 